
\subsection{Code-Ablauf}\label{subsec:code-ablauf}

Im Folgenden wird detailliert der Ablauf im Code dargestellt, welcher beim Ausnutzen der Schwachstelle abläuft.\\

Der Einstiegspunkt für das Programm ist abhängig vom übergebenen Shell-Befehl in der Kommandozeile.\\

Das konkrete Beispiel wird anhand folgendem "`convert"'-Befehl erläutert:

\begin{lstlisting}[language=Bash, caption=Beispielbefehl Codeablauf,label={lst:codeablaufbeispiel}]
convert 'https://example.com/image.png"|ls "-la' image.jpg
\end{lstlisting}
\vspace{5mm}

In dem Beispiel soll also ein PNG-Bild von einer Website heruntergeladen werden und zu einer JPG Datei konvertiert werden.
Im Hintergrund wird der "`ls -la"' Befehl ausgeführt, wodurch die hier betrachtete Schwachstelle ausgenutzt wird.\\\\
Weitere Beispiele sind in dem Kapitel "`Ausnutzung der Schwachstelle"' zu finden. \\

Nach dem Ausführen des convert-Befehls wird im ImageMagick-Ordner in der Datei utilities/convert.c die main()-Methode~\cite{DeklarationMain} ausgeführt.
Die Variable "`argv"' enthält alle übergebenen Command-Parameter.\\

\begin{lstlisting}[firstnumber=90, language=C, caption=utilities/convert.c Einstieg main(),label={lst:lstlisting}]
int main(int argc,char **argv)
{
  return(ConvertMain(argc,argv));
}
\end{lstlisting}
\vspace{5mm}

Parameter sind hier:
\begin{enumerate}
  \item Quellname, bestehend aus URL, sowie injectetem Command
  \item Zielname "`image.jpg"'
\end{enumerate}

Die main()-Methode ruft dann die ConvertMain()-Methode in derselben Datei~\cite{DeklarationConvertMain} auf.

\begin{lstlisting}[firstnumber=67, language=C, caption=utilities/convert.c ConvertMain(),label={lst:lstlisting}]
static int ConvertMain(int argc,char **argv)
{
  ...
  status=MagickCommandGenesis(image_info,ConvertImageCommand,argc,argv,(char **) NULL,exception);
  ...
  return(status != MagickFalse ? 0 : 1);
}
\end{lstlisting}
\vspace{5mm}

In dieser Methode ist besonders der Methodenaufruf "`MagickCommandGenesis()"'~\cite{AufbauMagickCommandGenesis} von Bedeutung.
Diese generische Methode wendet, basierend auf den Commandline-Argumenten, Verarbeitungsoperationen auf ein Bild an.\\\\
Welche Operationen genau ausgeführt werden, entscheidet der gewählte Command.
Für den convert-Befehl wird hier eine Referenz auf die Methode "`ConvertImageCommand"'~\cite{DeklarationConvertIMageCommand} übergeben.
Für jeden ImageMagick Befehl gibt es einen eigenen Command.
So zum Beispiel auch für den identify-Befehl die "`IdentifyImageCommand"'~\cite{DeklarationIdentifyImageCommand} Methode.\\

Außerdem werden die Commandline-Argumente an die Methode übergeben.
Der Rückgabewert, welcher in die Variable "`status"' geschrieben wird, gibt an, ob alle Operationen fehlerfrei angewendet werden konnten.\\

\newpage

Innerhalb der MagickCommandGenesis-Methode~\cite{DeklaraitionMagickCommandGenesis} werden nun zuerst einige Parameter überprüft, welche für alle ImageMagick Befehle gesetzt werden können~\cite{MagickCommandGenesisDebugFlag}.
Hier ist zum Beispiel die "`-debug"'-Flag zum Debugging zu nennen.

\begin{lstlisting}[firstnumber=158, language=Bash, caption=wand/migrify.c Debugging Flag in der MagickCommandGenesis-Methode,label={lst:migrifydebug}]
if (LocaleCompare("debug",option+1) == 0)
  (void) SetLogEventMask(argv[++i]);
\end{lstlisting}
\vspace{5mm}

Anschließend wird die übergebene Command-Methode "`ConvertImageCommand()"'~\cite{MagickCommandGenesisCommandAufruf} mit den convert-Befehlsargumenten ausgeführt:

\begin{lstlisting}[firstnumber=172, language=C, caption=wand/migrify.c Aufruf des ConvertImageCommand,label={lst:lstlisting}]
status=command(image_info,argc,argv,metadata,exception);
\end{lstlisting}
\vspace{5mm}


Die Methode ConvertImageCommand()~\cite{DeklarationConvertIMageCommand} befindet sich in wand/convert.c. Das Ziel der Methode ist es, Konvertierungs-Operationen auszuführen und eine neue Datei im passenden Format zu schreiben:\\

\begin{lstlisting}[firstnumber=498, language=C, caption=wand/convert.c ConvertImageCommand(),label={lst:lstlisting}]
WandExport MagickBooleanType ConvertImageCommand(ImageInfo *image_info,
  int argc,char **argv,char **metadata,ExceptionInfo *exception)
{
  ...
}
\end{lstlisting}
\vspace{5mm}

Innerhalb der Methode wird nun die ReadImages()-Methode~\cite{AufrufReadImages} aufgerufen:

\begin{lstlisting}[firstnumber=628, language=C, caption=wand/convert.c Aufruf ReadImages(),label={lst:lstlisting}]
  images=ReadImages(image_info,exception);
\end{lstlisting}
\vspace{5mm}

Die ReadImages()-Methode~\cite{DeklarationReadImages} befindet sich in magick/constitue.c, liest ein oder mehrere Bilder ein und gibt diese innerhalb einer Liste zurück.\\
In diesem Fall wird nur ein Bild eingelesen.
Manche ImageMagick Befehle, wie zum Beispiel der mogrify-Befehl~\cite{MogrifyCommand} erlauben jedoch direkt mehrere Bilder zu behandeln.\\

\begin{lstlisting}[firstnumber=790, language=C, caption=magick/constitute.c ReadImages(),label={lst:lstlisting}]
MagickExport Image *ReadImages(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  ...
}
\end{lstlisting}
\vspace{5mm}

Jedes einzelne Bild wird dann der ReadImage()-Methode übergeben.\\

Die Methode ReadImage() prüft nun ab, ob ein interner Decoder für das Bild vorhanden ist~\cite{ReadImageCheckInternal}.

\begin{lstlisting}[firstnumber=486, language=C, caption=magick/constitue.c Aufruf InvokeDelegate(),label={lst:}]
if ((magick_info != (const MagickInfo *) NULL) &&
    (GetImageDecoder(magick_info) != (DecodeImageHandler *) NULL))
  {
    // Interner Decoder vorhanden
    ...
    ...
  }
else
  {
    // Kein interner Decoder vorhanden: Muss von externem Delegate behandelt werden
    ...
    (void) InvokeDelegate(read_info,image,read_info->magick,(char *) NULL, exception);
    ...
\end{lstlisting}
\vspace{5mm}

Die Schwachstelle bezieht sich auf das externe HTTPS-Delegate.
Es wird also der else Zweig ausgeführt.\\

Im folgenden Abschnitt wird die Methode InvokeDelegate()~\cite{DeklarationInvokeDelegate} genauer betrachtet.
Sie befindet sich in der Datei magick/delegate.c.

\begin{lstlisting}[firstnumber=1097, language=C, caption=magick/delegate.c InvokeDelegate(),label={lst:lstlisting}]
MagickExport MagickBooleanType InvokeDelegate(ImageInfo *image_info,
  Image *image,const char *decode,const char *encode,ExceptionInfo *exception)
{
  ...
}
\end{lstlisting}
\vspace{5mm}

\newpage

Innerhalb der InvokeDelegate()-Methode werden nun zuerst einige Prüfungen durchgeführt.
Unter anderem wird abgeprüft, ob eine gesetzte Policy die Ausführung des Delegates verhindert~\cite{IsRightsAuthorized}.
Dies wird später auch bei der Verteidigung der Schwachstelle von Bedeutung sein.

\begin{lstlisting}[firstnumber=1129, language=C, caption=magick/delegates.c InvokeDelegate() Policy-Überprüfung,label={lst:delegatepolicy}]
if (IsRightsAuthorized(DelegatePolicyDomain,rights,decode) == MagickFalse)
  {
    errno=EPERM;
    (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,
      "NotAuthorized","`%s'",decode);
    return(MagickFalse);
  }
\end{lstlisting}
\vspace{5mm}


Nachdem diese Checks erfolgreich übersprungen wurden, wird der hinterlegte-Command aus dem Delegate,
zusammen mit den aktuellen Bild-Informationen and die Methode InterpretImageProperties() übergeben~\cite{CallInterpretImageProperties}.

\begin{lstlisting}[firstnumber=1295, language=C, caption=magick/delegates.c InvokeDelegate() InterpretImageProperties() Aufruf,label={lst:delegatesinterpretcall}]
command=InterpretImageProperties(image_info,image,commands[i]);
\end{lstlisting}
\vspace{5mm}

Das Ziel der InterpretImageProperties-Methode~\cite{DeklarationInterpretImageProperties} ist es, in dem Delegate eingebettete Platzhalter mit den entsprechenden Bild-Attributen zu ersetzen.
Rückgabe der Methode ist der neue Command ohne Platzhalter.
Auf mögliche Platzhalter wird gleich noch genauer eingegangen.\\

Für jeden gefundenen Platzhalter wird die Methode GetMagickProperty()~\cite{CallGetMagickPrioerty} aufgerufen.
Diese ersetzt einen einzelnen Platzhalter mit dem dazugehörigen Bild-Attribut.\\

In der Methode GetMagickProperty()~\cite{DeklarationGetMagickProperty} wird eine Unterscheidung zwischen Property-Lettern,
also Platzhaltern mit einem einzelnen Zeichen (z.B. \%M) und Platzhaltern mit mehreren Zeichen (z.B \%basename) getroffen~\cite{UnterscheidungPropertyLetter}.\\

Für Platzhalter mit einem Zeichen wird die Methode GetMagickPropertyLetter()~\cite{DeklarationGetMgickPropertyLetter} aufgerufen.
Das HTTPS Delegate hat den Platzhalter \%M in dem Command.
Es handelt sich also um einen Platzhalter, welcher in der GetMagickPropertyLetter() ersetzt wird.\\

\newpage

Die Methode GetMagickPropertyLetter() enthält einen großen Switch-Case Block~\cite{SwitchBlock} mit allen implementierten Platzhalter-Zeichen.

\begin{lstlisting}[language=C, caption=magick/property.c GetMagickPropertyLetter Switch über mögliche Platzhalter,label={lst:propertyswitch}]
switch (letter)
{
  case 'b':
  {
    /*
      Image size read in - in bytes.
    */
    (void) FormatMagickSize(image->extent,MagickFalse,value);
    if (image->extent == 0)
      (void) FormatMagickSize(GetBlobSize(image),MagickFalse,value);
    break;
  }
  ...
  case 'M':
  {
    /*
      Magick filename - filename given incl. coder & read mods.
    */
    string=image->magick_filename;
    break;
  ...
  }
\end{lstlisting}
\vspace{5mm}

Hier ist unter anderem auch unser Platzhalter \%M~\cite{caseM} aus dem HTTPS Delegate zu finden.
Die Methode geht in den case-Block und setzt die Variable "`string"' auf den übergebenen Filenamen.
Der Inhalt der Variable "`string"' wird am Ende des Switch-Blocks an den Aufrufer zurückgegeben.\\

Dies hat zur Folge, dass in dem Delegate-Command der Platzhalter \%M mit dem übergebenen Dateinamen,
also der URL und dem injecteten ls-Commands, ersetzt wird.\\

Nachdem aus dem Delegate-Befehl alle Parameter ersetzt wurden, wird dieser an die Methode ExternalDelegateCommand()~\cite{CallExternalDelegateCommand} weitergegeben.

\begin{lstlisting}[firstnumber=1301, language=C, caption=magick/delegate.c Aufruf ExternalDelegateCommand(),label={lst:lstlisting}]
  status=ExternalDelegateCommand(delegate_info->spawn,image_info->verbose,
    command,(char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;
\end{lstlisting}
\vspace{5mm}

Innerhalb der ExternalDelegateCommand()-Methode~\cite{DeklarationExternalDelegateCommand} wird die Methode SanitizeDelegateCommand() aufgerufen~\cite{CallSanatizeDelegateCommand}:\\

\begin{lstlisting}[firstnumber=395, language=C, caption=magick/delegate.c Aufruf SanitizeDelegateCommand(),label={lst:lstlisting}]
  sanitize_command=SanitizeDelegateCommand(command);
\end{lstlisting}
\vspace{5mm}

\newpage

Die SanitizeDelegateCommand()-Methode~\cite{DeclareSanatizeDelegateCommand} bereinigt das übergebene Kommando, filtert also unzulässige Zeichen heraus:\\

\begin{lstlisting}[firstnumber=322, language=C, caption=magick/delegate.c SanitizieDelegateCommand(),label={lst:lstlisting}]
static char *SanitizeDelegateCommand(const char *command)
{
  char
    *sanitize_command;

  const char
    *q;

  register char
    *p;

  static char
    whitelist[] =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_- "
      ".@&;<>()|/\\\'\":%=~`";

  sanitize_command=AcquireString(command);
  p=sanitize_command;
  q=sanitize_command+strlen(sanitize_command);
  for (p+=strspn(p,whitelist); p != q; p+=strspn(p,whitelist))
    *p='_';
  return(sanitize_command);
}
\end{lstlisting}
\vspace{5mm}

Nach dem "`Sanitizen"' wird dann das bereinigte Kommando direkt an die system()-Methode~\cite{SystemCall} in die Shell übergeben:\\

\begin{lstlisting}[firstnumber=402, language=C, caption=magick/delegate.c Aufruf system(),label={lst:lstlisting}]
  status=system(sanitize_command);
\end{lstlisting}
\vspace{5mm}

Der zum Ausnutzen der Schwachstelle eingefügte Shell-Befehl wird dann mit ausgeführt.
\newpage